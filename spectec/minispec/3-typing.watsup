;; Contexts

syntax context hint(desc "context") =
  { FUNC functype*, GLOBAL globaltype*,
    LOCAL valtype*, LABEL resulttype*, RETURNS resulttype? }

var C : context



;; Types

relation Functype_ok: |- functype : OK      hint(show "K-func")
relation Globaltype_ok: |- globaltype : OK  hint(show "K-global")


rule Functype_ok:
  |- ft : OK

rule Globaltype_ok:
  |- gt : OK


;; Instructions

relation Instr_ok: context |- instr : functype     hint(show "T")
relation InstrSeq_ok: context |- instr* : functype hint(show "T*")
relation Expr_ok: context |- expr : resulttype     hint(show "T-expr")


rule Expr_ok:
  C |- instr* : t*
  -- InstrSeq_ok: C |- instr* : epsilon -> t*


rule InstrSeq_ok/empty:
  C |- epsilon : epsilon -> epsilon

rule InstrSeq_ok/seq:
  C |- instr_1 instr_2* : t_1* -> t_3*
  -- Instr_ok: C |- instr_1 : t_1* -> t_2*
  -- InstrSeq_ok: C |- instr_2 : t_2* -> t_3*

rule InstrSeq_ok/weak:
  C |- instr* : t_1 -> t_2*
  -- InstrSeq_ok: C |- instr* : t_1* -> t_2*

rule InstrSeq_ok/frame:
  C |- instr* : t* t_1* -> t* t_2*
  -- InstrSeq_ok: C |- instr* : t_1* -> t_2*


rule Instr_ok/unreachable:
  C |- UNREACHABLE : t_1* -> t_2*

rule Instr_ok/nop:
  C |- NOP : epsilon -> epsilon

rule Instr_ok/drop:
  C |- DROP : t -> epsilon


rule Instr_ok/select-expl:
  C |- SELECT t : t t I32 -> t

rule Instr_ok/select-impl:
  C |- SELECT : t t I32 -> t
  -- if t = numtype


relation Blocktype_ok: context |- blocktype : functype hint(show "K-block")

rule Blocktype_ok:
  C |- ft : ft
  -- Functype_ok: |- ft : OK

rule Instr_ok/block:
  C |- BLOCK bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr* : t_1* -> t_2*

rule Instr_ok/loop:
  C |- LOOP bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_1* |- instr* : t_1* -> t_2*

rule Instr_ok/if:
  C |- IF bt instr_1* ELSE instr_2* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr_1* : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr_2* : t_1* -> t_2*


rule Instr_ok/br:
  C |- BR l : t_1* t* -> t_2*
  -- if C.LABEL[l] = t*

rule Instr_ok/br_if:
  C |- BR_IF l : t* I32 -> t*
  -- if C.LABEL[l] = t*

rule Instr_ok/return:
  C |- RETURN : t_1* t* -> t_2*
  -- if C.RETURNS = (t*)

rule Instr_ok/call:
  C |- CALL x : t_1* -> t_2*
  -- if C.FUNC[x] = t_1* -> t_2*


rule Instr_ok/const:
  C |- CONST nt c_nt : epsilon -> nt

rule Instr_ok/unop:
  C |- UNOP nt unop : nt -> nt

rule Instr_ok/binop:
  C |- BINOP nt binop : nt nt -> nt

rule Instr_ok/testop:
  C |- TESTOP nt testop : nt -> I32

rule Instr_ok/relop:
  C |- RELOP nt relop : nt nt -> I32


rule Instr_ok/local.get:
  C |- LOCAL.GET x : epsilon -> t
  -- if C.LOCAL[x] = t

rule Instr_ok/local.set:
  C |- LOCAL.SET x : t -> epsilon
  -- if C.LOCAL[x] = t

rule Instr_ok/local.tee:
  C |- LOCAL.TEE x : t -> t
  -- if C.LOCAL[x] = t


rule Instr_ok/global.get:
  C |- GLOBAL.GET x : epsilon -> t
  -- if C.GLOBAL[x] = MUT? t

rule Instr_ok/global.set:
  C |- GLOBAL.SET x : t -> epsilon
  -- if C.GLOBAL[x] = MUT t


;; Constant Expressions

relation Instr_const: context |- instr CONST             hint(show "C-instr")
relation Expr_const: context |- expr CONST               hint(show "C-expr")
relation Expr_ok_const: context |- expr : valtype CONST  hint(show "TC-expr")

rule Instr_const/const:
  C |- (CONST nt c) CONST

rule Instr_const/global.get:
  C |- (GLOBAL.GET x) CONST
  -- if C.GLOBAL[x] = epsilon t


rule Expr_const: C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*


rule Expr_ok_const:
  C |- expr : t CONST
  -- Expr_ok: C |- expr : t
  -- Expr_const: C |- expr CONST


;; Modules

relation Func_ok: context |- func : functype         hint(show "T-func")
relation Global_ok: context |- global : globaltype   hint(show "T-global")
relation Start_ok: context |- start : OK             hint(show "T-start")


rule Func_ok:
  C |- FUNC ft t* expr : ft
  -- if ft = t_1* -> t_2*
  -- Functype_ok: |- ft : OK
  -- Expr_ok: C, LOCAL t_1* t*, LABEL (t_2*), RETURNS (t_2*) |- expr : t_2*

rule Global_ok:
  C |- GLOBAL gt expr : gt
  -- Globaltype_ok: |- gt : OK
  -- if gt = MUT? t
  -- Expr_ok_const: C |- expr : t CONST

rule Start_ok:
  C |- START x : OK
  -- if C.FUNC[x] = epsilon -> epsilon


relation Module_ok: |- module : OK      hint(show "T-module")

rule Module_ok:
  |- MODULE func* global* start* : OK
  ;; TODO: incremental contexts for globals
  -- if C = {FUNC ft*, GLOBAL gt*}

  -- (Func_ok: C |- func : ft)*
  -- (Global_ok: C |- global : gt)*

  -- (Start_ok: C |- start : OK)*

  -- if |start*| <= 1
  ;; -- TODO: disjoint export names
