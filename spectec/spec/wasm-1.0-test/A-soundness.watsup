;; Store and Frame 
var S : store
var F : frame
var rt : resulttype

;; Value type ok

relation Val_ok: |- val : valtype

rule Val_ok:
  |- CONST t c_t : t


;; Result type ok

relation Result_ok: |- result : valtype*

rule Result_ok/result:
  |- _VALS v* : t*
  -- (Val_ok: |- v : t)*

rule Result_ok/trap:
  |- TRAP : t*

;; Externvals

relation Externvals_ok: store |- externval : externtype

rule Externvals_ok/func:
  S |- FUNC a : FUNC ext
    -- if S.FUNCS[a] = {TYPE ext, MODULE minst, CODE code_func}

rule Externvals_ok/table:
  S |- TABLE a : TABLE tt
    -- if S.TABLES[a] = {TYPE tt', REFS fa?*}
    -- Tabletype_sub: |- tt' <: tt

rule Externvals_ok/mem:
  S |- MEM a : MEM mt
    -- if S.MEMS[a] = {TYPE mt', BYTES b*}
    -- Memtype_sub: |- mt' <: mt

rule Externvals_ok/global:
  S |- GLOBAL a : GLOBAL (mut valtype)
    -- if S.GLOBALS[a] = {TYPE (mut valtype), VALUE (CONST valtype val_)}

;; Memory instance 

relation Memory_instance_ok: store |- meminst : memtype

rule Memory_instance_ok:
  S |- {TYPE mt, BYTES b*} : mt
  -- if mt = `[n .. m]
  -- if $(|b*| = n * 64 * $Ki)
  -- Memtype_ok : |- mt : OK

;; Table instance

relation Table_instance_ok: store |- tableinst : tabletype

rule Table_instance_ok:
  S |- {TYPE tt, REFS (fa?)*} : tt
  -- if tt = `[n .. m]
  -- ((Externvals_ok: S |- FUNC fa : FUNC functype)?)*
  -- Tabletype_ok : |- tt : OK

;; Global Instance

relation Global_instance_ok: store |- globalinst : globaltype

rule Global_instance_ok:
  S |- {TYPE gt, VALUE v} : gt
    -- if gt = mut vt
    -- Globaltype_ok: |- gt : OK
    -- Val_ok: |- v : vt

;; Export Instance

relation Export_instance_ok: store |- exportinst : OK

rule Export_instance_ok:
  S |- {NAME name, VALUE eval} : OK
    -- Externvals_ok: S |- eval : ext

;; Module Instance

relation Module_instance_ok: store |- moduleinst : context

rule Module_instance_ok:
  S |- { TYPES functype*, FUNCS funcaddr*, GLOBALS globaladdr*, TABLES tableaddr*, MEMS memaddr*, EXPORTS exportinst* } : {TYPES functype*, FUNCS functype'*, GLOBALS globaltype*, TABLES tabletype*, MEMS memtype*}
    -- (Functype_ok: |- functype : OK)*
    -- (Externvals_ok: S |- FUNC funcaddr : FUNC functype')*
    -- (Externvals_ok: S |- TABLE tableaddr : TABLE tabletype)*
    -- (Externvals_ok: S |- GLOBAL globaladdr : GLOBAL globaltype)*
    -- (Externvals_ok: S |- MEM memaddr : MEM memtype)*
    -- (Export_instance_ok: S |- exportinst : OK)*
    ;; TODO disjoint exportinst.name

;; Function instance

relation Function_instance_ok: store |- funcinst : functype

rule Function_instance_ok:
  S |- { TYPE functype, MODULE moduleinst, CODE func } : functype
  -- Functype_ok: |- functype : OK
  -- Module_instance_ok: S |- moduleinst : C
  -- Func_ok: C |- func : functype

;; Store ok

relation Store_ok: |- store : OK

rule Store_ok:
  |- S : OK
  -- if S = {FUNCS funcinst*, GLOBALS globalinst*, TABLES tableinst*, MEMS meminst*}
  -- (Function_instance_ok: S |- funcinst : functype)*
  -- (Global_instance_ok: S |- globalinst : globaltype)*
  -- (Table_instance_ok: S |- tableinst : tabletype)*
  -- (Memory_instance_ok: S |- meminst : memtype)*

;; Administrative instructions ok

relation Admin_instr_ok: store; context |- admininstr : functype
relation Admin_instrs_ok: store; context |- admininstr* : functype
relation Thread_ok: store ; resulttype? |- frame; admininstr* : resulttype


;; Administrative instruction sequences

rule Admin_instrs_ok/empty:
  S; C |- eps : eps -> eps

rule Admin_instrs_ok/seq:
  S; C |- admininstr_1* admininstr_2 : t_1* -> t_3*
  -- Admin_instrs_ok: S; C |- admininstr_1* : t_1* -> t_2*
  -- Admin_instr_ok: S; C |- admininstr_2 : t_2* -> t_3*

rule Admin_instrs_ok/frame:
  S; C |- admininstr* : t* t_1* -> t* t_2*
  -- Admin_instrs_ok: S; C |- admininstr* : t_1* -> t_2*

rule Admin_instrs_ok/instrs:
  S; C |- instr* : functype
  -- Instrs_ok: C |- instr* : functype

;; Administrative intructions 

rule Admin_instr_ok/instr:
  S; C |- instr : functype
  -- Instr_ok: C |- instr : functype

rule Admin_instr_ok/trap:
  S; C |- TRAP : t_1* -> t_2*

rule Admin_instr_ok/call_addr:
  S; C |- CALL_ADDR funcaddr : t_1* -> t_2?
  -- Externvals_ok: S |- FUNC funcaddr: FUNC (t_1* -> t_2?)

rule Admin_instr_ok/label:
  S; C |- LABEL_ n `{instr*} admininstr* : eps -> t_2?
  -- Instrs_ok: C |- instr*: t_1? -> t_2?
  -- Admin_instrs_ok: S; $($(C, LABELS (t_1?))) |- admininstr*: eps -> t_2?
  -- if $(n = $optionSize(t_1?))

rule Admin_instr_ok/frame:
  S; C |- FRAME_ n `{F} admininstr* : eps -> t?
  -- Thread_ok: S; t? |- F; admininstr*: t?
  -- if $(n = $optionSize(t?))

rule Admin_instr_ok/weakening:
  S; C |- admininstr : t* t_1* -> t* t_2*
  -- Admin_instr_ok: S; C |- admininstr : t_1* -> t_2*

;; Configuration validity

relation Frame_ok: store |- frame : context

rule Frame_ok:
  S |- { LOCALS val*, MODULE moduleinst } : C, LOCALS t*
  -- Module_instance_ok: S |- moduleinst : C
  -- (Val_ok: |- val : t)*

rule Thread_ok:
  S; rt? |- F; admininstr* : t?
  -- Frame_ok: S |- F : C
  -- Admin_instrs_ok: S; $($(C, RETURN rt?)) |- admininstr* : eps -> t?

relation Config_ok: |- config : resulttype

rule Config_ok:
  |- S; F; admininstr* : t?
  -- Store_ok: |- S : OK
  -- Thread_ok: S; eps |- F; admininstr* : t?



;; Store Extension 

relation Func_extension: |- funcinst : funcinst
relation Table_extension: |- tableinst : tableinst
relation Mem_extension: |- meminst : meminst
relation Global_extension: |- globalinst : globalinst
relation Store_extension: |- store : store

rule Func_extension:
  |- funcinst : funcinst

rule Table_extension:
  |- {TYPE `[n1..m], REFS (fa_1?)*} : {TYPE `[n2..m], REFS (fa_2?)*}
  -- if n1 <= n2

rule Mem_extension:
  |- {TYPE `[n1..m], BYTES b_1*} : {TYPE `[n2..m], BYTES b_2*}
  -- if n1 <= n2

rule Global_extension:
  |- {TYPE (mut t2), VALUE (CONST t2 c1)} : {TYPE (mut t2), VALUE (CONST t2 c2)}
  -- if (mut = MUT) \/ c1 = c2

rule Store_extension:
  |- store_1 : store_2
  -- if store_1.FUNCS = funcinst_1*
  -- if store_1.TABLES = tableinst_1*
  -- if store_1.MEMS = meminst_1*
  -- if store_1.GLOBALS = globalinst_1*
  -- if store_2.FUNCS = funcinst_1'* funcinst_2*
  -- if store_2.TABLES = tableinst_1'* tableinst_2*
  -- if store_2.MEMS = meminst_1'* meminst_2*
  -- if store_2.GLOBALS = globalinst_1'* globalinst_2*
  -- (Func_extension: |- funcinst_1: funcinst_1')*
  -- (Table_extension: |- tableinst_1: tableinst_1')*
  -- (Mem_extension: |- meminst_1: meminst_1')*
  -- (Global_extension: |- globalinst_1: globalinst_1')*

def $types__of(val*) : valtype*
def $types__of(eps) = eps
def $types__of((CONST valtype val_) val'*) = valtype $types__of(val'*)

def $is__const(admininstr) : bool
  hint(prose "% is a constant")
def $is__const(CONST valtype val_) = true
def $is__const(admininstr) = false

def $const__list(admininstr*) : bool
  hint(prose "% is a list of constants")
def $const__list(eps) = true
def $const__list(admininstr admininstr'*) = 
  $is__const(admininstr) /\ $const__list(admininstr'*)

def $not__lf__br(admininstr*) : bool
  hint(prose "% is not branch-reducidible")
def $not__lf__br(admininstr*) =
  forall (val*, l, admininstr'*)
  admininstr* =/= val* (BR l) admininstr'*

def $not__lf__return(admininstr*) : bool
  hint(prose "% is not return-reducidible")
def $not__lf__return(admininstr*) =
  forall (val*, l, admininstr'*)
  admininstr* =/= val* (RETURN) admininstr'*

def $terminal__form(admininstr*) : bool
  hint(prose "% is in terminal form")
def $terminal__form(admininstr*) = 
  $const__list(admininstr*) \/ admininstr* = TRAP

var lab : resulttype
var ret : resulttype

theorem t_progress hint(desc "Progress") =
  forall (s, f, admininstr*, t?)
  @(Config_ok: |- s; f; admininstr* : t?) =>
  $terminal__form(admininstr*) \/
  exists (s', f', admininstr'*)
  @(Step: s; f; admininstr* ~> s'; f'; admininstr'*)

lemma t_progress_e hint(desc "Admin Fragment Progress") =
  forall (s, C, C', f, val*, admininstr*, ft, valtype_1*, valtype_2*, lab*, ret?)
  @(Admin_instrs_ok: s; C |- admininstr* : ft) => 
  ft = (valtype_1* -> valtype_2*) =>
  C = $($(C', LOCALS $types__of(f.LOCALS), LABELS lab*, RETURN ret?)) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  $types__of(val*) = valtype_1* =>
  @(Store_ok: |- s : OK) =>
  $not__lf__br(admininstr*) =>
  $not__lf__return(admininstr*) =>
  $terminal__form(val* admininstr*) \/
  exists (s', f', admininstr'*)
  @(Step: s; f; val* admininstr* ~> s'; f'; admininstr'*)

lemma t_progress_be hint(desc "Basic Fragment Progress") =
  forall (s, C, C', f, val*, instr*, ft, valtype_1*, valtype_2*, lab*, ret?)
  @(Instrs_ok: C |- instr* : ft) =>
  ft = (valtype_1* -> valtype_2*) =>
  C = $($(C', LOCALS $types__of(f.LOCALS), LABELS lab*, RETURN ret?)) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  $types__of(val*) = valtype_1* =>
  @(Store_ok: |- s : OK) =>
  $not__lf__br(instr*) =>
  $not__lf__return(instr*) =>
  $const__list(instr*) \/
  exists (s', f', admininstr*)
  @(Step: s; f; val* instr* ~> s'; f'; admininstr*)

def $t__progress' : bool
  hint(proof "theorem") 
  hint(desc "Progress")
def $t__progress' = forall (s, f, admininstr*, t?)
  @(Config_ok: |- s; f; admininstr* : t?) =>
  $terminal__form(admininstr*) \/
  exists (s', f', admininstr'*)
  @(Step: s; f; admininstr* ~> s'; f'; admininstr'*)

def $t__progress__e' : bool
  hint(proof "lemma")
  hint(desc "Admin Fragment Progress")
def $t__progress__e' = forall (s, C, C', f, val*, admininstr*, ft, valtype_1*, valtype_2*, lab*, ret?)
  @(Admin_instrs_ok: s; C |- admininstr* : ft) => 
  ft = (valtype_1* -> valtype_2*) =>
  C = $($(C', LOCALS $types__of(f.LOCALS), LABELS lab*, RETURN ret?)) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  $types__of(val*) = valtype_1* =>
  @(Store_ok: |- s : OK) =>
  $not__lf__br(admininstr*) =>
  $not__lf__return(admininstr*) =>
  $terminal__form(val* admininstr*) \/
  exists (s', f', admininstr'*)
  @(Step: s; f; val* admininstr* ~> s'; f'; admininstr'*)

def $t__progress__be' : bool
  hint(proof "lemma")
  hint(desc "Basic Fragment Progress")
def $t__progress__be' = forall (s, C, C', f, val*, instr*, ft, valtype_1*, valtype_2*, lab*, ret?)
  @(Instrs_ok: C |- instr* : ft) =>
  ft = (valtype_1* -> valtype_2*) =>
  C = $($(C', LOCALS $types__of(f.LOCALS), LABELS lab*, RETURN ret?)) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  $types__of(val*) = valtype_1* =>
  @(Store_ok: |- s : OK) =>
  $not__lf__br(instr*) =>
  $not__lf__return(instr*) =>
  $const__list(instr*) \/
  exists (s', f', admininstr*)
  @(Step: s; f; val* instr* ~> s'; f'; admininstr*)

lemma t_pure_preservation hint(desc "Pure Preservation") =
  forall (s, mm, admininstr*, admininstr'*, C, C', valtype*, lab*, ret?, ft)
  @(Module_instance_ok: s |- mm : C) =>
  C' = $($(C, LOCALS valtype*, RETURN ret?, LABELS lab*)) =>
  @(Admin_instrs_ok: s; C' |- admininstr* : ft) =>
  @(Step_pure: admininstr* ~> admininstr'*) =>
  @(Admin_instrs_ok: s; C' |- admininstr'* : ft)

lemma t_read_preservation hint(desc "Read Preservation") =
  forall (s, f, admininstr*, admininstr'*, C, C', val*, valtype*, valtype_1*, valtype_2*, lab*, ret?)
  @(Step_read: s; f; admininstr* ~> admininstr'*) =>
  @(Store_ok: |- s : OK) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  val* = f.LOCALS =>
  @(@(Val_ok: |- val : valtype))* =>
  C' = $($(C, LOCALS valtype* C.LOCALS, RETURN ret?, LABELS lab*)) =>
  @(Admin_instrs_ok: s; C' |- admininstr* : (valtype_1* -> valtype_2*)) =>
  @(Admin_instrs_ok: s; C' |- admininstr'* : (valtype_1* -> valtype_2*))

lemma t_preservation_type hint(desc "Fragment Preservation") = 
  forall (s, f, admininstr*, s', f', admininstr'*, C, C', val*, valtype*, valtype_1*, valtype_2*, lab*, ret?)
  @(Step: s; f; admininstr* ~> s'; f'; admininstr'*) =>
  @(Store_ok: |- s : OK) =>
  @(Store_ok: |- s' : OK) =>
	@(Store_extension: |- s : s') =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  @(Module_instance_ok: s' |- f.MODULE : C) =>
  val* = f.LOCALS =>
  @(@(Val_ok: |- val_1 : valtype))* =>
  C' = $($(C, LOCALS valtype* C.LOCALS, RETURN ret?, LABELS lab*)) =>
  @(Admin_instrs_ok: s; C' |- admininstr* : (valtype_1* -> valtype_2*)) =>
  @(Admin_instrs_ok: s'; C' |- admininstr'* : (valtype_1* -> valtype_2*))

;; TODO: Rewrite with config and config'
theorem t_preservation hint(desc "Preservation") = 
  forall (s, f, admininstr*, s', f', admininstr'*, rt)
	@(Step: s; f; admininstr* ~> s'; f'; admininstr'*) =>
	@(Config_ok: |- s; f; admininstr* : rt) =>
  @(Config_ok: |- s'; f'; admininstr'* : rt)

template
lemma Step_pure__preserves = 
  forall (s, C, ft, {{ ...relations.Step_pure.rules.*.freevars }})
  @(Admin_instrs_ok: s; C |- {{ relations.Step_pure.rules.*.before }} : ft) =>
  @(Step_pure: {{ relations.Step_pure.rules.*.before }} ~> {{ relations.Step_pure.rules.*.after }}) =>
  {{ relations.Step_pure.rules.*.premises }} =>
  @(Admin_instrs_ok: s; C |- eps : ft)

template
lemma Step_read__preserves = 
  ;; TODO: Requires _1 suffixes to prevent conflicts
  forall (s, f, C, C', ft, val_1*, valtype_1*, lab*, ret?, {{ ...relations.Step_read.rules.*.freevars }})
  C' = $($(C, LOCALS valtype_1* C.LOCALS, RETURN ret?, LABELS lab*)) =>
  @(Admin_instrs_ok: s; C' |- {{ relations.Step_read.rules.*.before }} : ft) =>
  @(Module_instance_ok: s |- f.MODULE : C) =>
  {{ relations.Step_read.rules.*.premises }} =>
  val_1* = f.LOCALS =>
  @(@(Val_ok: |- val_1 : valtype_1))* =>
  @(Admin_instrs_ok: s; C' |- {{ relations.Step_read.rules.*.after }} : ft)
